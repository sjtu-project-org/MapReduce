package sjtu.sdic.mapreduce.core;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import sjtu.sdic.mapreduce.common.KeyValue;
import sjtu.sdic.mapreduce.common.Utils;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;

/**
 * Created by Cachhe on 2019/4/19.
 */
public class Mapper {
    /**
     * doMap manages one map task: it should read one of the input files
     * {@code inFile}, call the user-defined map function {@code mapFunc} for
     * that file's contents, and partition mapFunc's output into {@code nReduce}
     * intermediate files.
     *
     * There is one intermediate file per reduce task. The file name
     * includes both the map task number and the reduce task number. Use
     * the filename generated by {@link Utils#reduceName(String, int, int)}
     * as the intermediate file for reduce task r. Call
     * {@link Mapper#hashCode(String)} on each key, mod nReduce,
     * to pick r for a key/value pair.
     *
     * {@code mapFunc} is the map function provided by the application. The first
     * argument should be the input file name, though the map function
     * typically ignores it. The second argument should be the entire
     * input file contents. {@code mapFunc} returns a list containing the
     * key/value pairs for reduce; see {@link KeyValue} for the definition of
     * KeyValue.
     *
     * Look at Java's File and Files API for functions to read
     * and write files.
     *
     * Coming up with a scheme for how to format the key/value pairs on
     * disk can be tricky, especially when taking into account that both
     * keys and values could contain newlines, quotes, and any other
     * character you can think of.
     *
     * One format often used for serializing data to a byte stream that the
     * other end can correctly reconstruct is JSON. You are not required to
     * use JSON, but as the output of the reduce tasks *must* be JSON,
     * familiarizing yourself with it here may prove useful. There're many
     * JSON-lib for Java, and we recommend and supply with FastJSON powered by
     * Alibaba. You can refer to official docs or other resources to figure
     * how to use it.
     *
     * The corresponding decoding functions can be found in {@link Reducer}.
     *
     * Remember to close the file after you have written all the values!
     *
     * Your code here (Part I).
     *
     * @param jobName the name of the MapReduce job
     * @param mapTask which map task this is
     * @param inFile file name (if in same dir, it's also the file path)
     * @param nReduce the number of reduce task that will be run ("R" in the paper)
     * @param mapFunc the user-defined map function
     */
    public static void doMap(String jobName, int mapTask, String inFile, int nReduce, MapFunc mapFunc) {
        Utils.debug("doMap:jobName:" + jobName + "    mapTask:"+String.valueOf(mapTask) + "   inFile:"+inFile + " nReduce:"+String.valueOf(nReduce));
        //read file content
        JSONObject json = new JSONObject(new LinkedHashMap());
        JSONObject res[] = new JSONObject[nReduce];
        try {
            BufferedInputStream in = new BufferedInputStream(new FileInputStream(inFile));
            String content = "";
            int r = -1;
            byte[] bytes = new byte[2048];
            while((r = in.read(bytes, 0, bytes.length)) != -1){
                String str = new String(bytes,0,r,"UTF-8");
                content = content + str;
            }
            in.close();
            List<KeyValue> kv = mapFunc.map(inFile, content);
            //for each Key-Value pair, transform value to JSONArray, but just a simple 't.value'
            //then transform JSONArray to String, store this String as the final json's relative key's value
            for(KeyValue t:kv){
                String key = t.key;
                if(json.containsKey(key)){
                    //if exists, update its ValueArray
                    Utils.debug("existing, update\n");
                    String oldValue = json.getString(key);
                    JSONArray vJson = JSONArray.parseArray(oldValue);
                    vJson.add("1");
                    String newValue = vJson.toString();
                    json.replace(key, newValue);
                }
                else{
                    //construct a new pair
                    //get String[] value, add new value in it (actually, it is 1)
                    Utils.debug("not existing, construct\n");
                    JSONArray vJson = new JSONArray();
                    vJson.add(t.value);
                    String newValue = vJson.toJSONString();
                    json.put(t.key, newValue);
                }

            }
            Utils.debug("after map, json size:" + String.valueOf(json.size()));
        }catch (Exception e){
            e.printStackTrace();
            Utils.debug("file reading error\n");
        }
        //loop reduce works
        for(int i = 0; i < nReduce; ++i){
            String filename = Utils.reduceName(jobName, mapTask, i);
            Utils.debug("map intermidiate filename:" + filename);
            JSONObject curJson = new JSONObject(new LinkedHashMap<>());
            //for each json obj, store them in correct Reducer(judge with hahsCode's ans mod nReduce)
            for(Map.Entry<String, Object> e: json.entrySet()){
                //select Reducer
                if(hashCode(e.getKey()) % nReduce == i){
                    curJson.put(e.getKey(), e.getValue());
                }
            }
            //save curJson in immidiate file
            try {
                FileWriter fw = new FileWriter(filename, false);
                BufferedWriter bw = new BufferedWriter(fw);
                String content = curJson.toString();
                bw.write(content);
                bw.close();
                fw.close();
            }catch (Exception e ){
                e.printStackTrace();
                Utils.debug("file saving error\n");
            }
        }
    }

    /**
     * a simple method limiting hash code to be positive
     *
     * @param src string
     * @return a positive hash code
     */
    private static int hashCode(String src) {
        return src.hashCode() & Integer.MAX_VALUE;
    }
}
